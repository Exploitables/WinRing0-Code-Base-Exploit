# WinRing0-Code-Base-Exploit
 
### Exploitation Notes
 Something that I learned after reverse engineering the device driver and basic kernel debugging, is that this vulnerability is likely infeasible to exploit reliably. Let's analyze the provided if-statement in the WinRing0 driver code-base:
```C
#ifndef _PHYSICAL_MEMORY_SUPPORT

    if(0x000C0000 > address.QuadPart 
    || (address.QuadPart + size - 1) > 0x000FFFFF)
    {
        return STATUS_INVALID_PARAMETER;
    }

#endif
```

As we can see, the driver performs two checks:
1) It checks if the supplied physical address is less than `0xC0000`. If the provided physical address is less than this hard-coded limit, the function returns with an `NTSTATUS` of `STATUS_INVALID_PARAMETER` (`0x0C000000D`).
2) It also checks if the address supplied plus the size of the user-land output buffer minus `1` is greater than `0xFFFFF`. If the first operand is greater than this hard-coded limit, it also returns `STATUS_INVALID_PARAMETER`.

All fine and dandy, that is until you find out addresses are *randomized*. After ten consecutive checks with the same physical address and output buffer length parameters, that was when the realistic exploitability of this device driver was determined. What is the exploitability of this driver, you may ask?

**This device driver is not reliably exploitable, or possible to exploit at all**.
